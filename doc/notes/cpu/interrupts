for AMD64, there is an interrupt table register, which stores the base address
for the interrupt table.

How the interrupt table works appears to depend on what mode the CPU is in,
I belive the multiboot specification specifies what mode the os starts in.

Apparently it starts in protected mode.

Relevent stuff from AMD64 architecture programmers manual, volume 2
"
In protected mode, the interrupt mechanism transfers control to an exception or
interrupt handler through gate descriptors. In protected mode, the IDT is a 
table of 8-byte gate entries, one for each of the 256 possible interrupt vectors
implemented by the system. Three gate types are allowed in the IDT:
	* Interrupt gates
	* Trap gates.
	* Task gates

When an exception or interrupt occurs, the processor scales the interrupt 
vector number by eight and uses the result as an offset into the IDT. If the 
gate descriptor referenced by the IDT offset is an interrupt gate or a trap 
gate, it contains a segment-selector and segment-offset field. These two
fields perform the same function as the pointer operatnd in a far 
control-transfer instruction. The gate-descriptor segment-selector field points
to the target code-segment descriptor located in either the GDT or LDT. The 
gate-descriptor segment-selector field points to the target code-segment 
descriptor located in either the GDT or LDT. The gate-descriptor segment-offset
field is the instruction-pointer offset into the interrupt-handler code segment.
The code-segment base taken from the code-segment descriptor is added to the
gate-descriptor segment-offset field to create the interrupt-handler virtual
address.

/* some permissions info we'll skip */

A return to an interrupted program should be performed using the IRET 
instruction.
"

Relevant stuff from 64-32intel_manual:
"
Externel interrupts, software interrupts and exceptions are handled through
the Interrupt Descriptor Table (IDT). The IDT stores a collection of gate
descriptors that provide access to interrupt and exception handlers. Like the
GDT, the IDT is not a segment. The linear address for the base of the
IDT is contained in the IDT register (IDTR).

Gate descriptors in the IDT can be interrupt, trap, or task gate descriptors.
To access and interrupt or exception handler, the processor first receives an
interrupt vector from internal hardware, and external interrupt controller, or
from software by means of an INT, INTO, INT 3, or BOUND instruction. The 
interrupt vector provides an index into the IDT. If the descriptor is a task
gate, the handler is accessed through a task switch.
"
same book, different chapter:
"
The IDT is an array of 256 8-byte descriptors.

The IDT may reside anywhere in the linear address space.

The LIDT (load IDT register) and SIDT (store IDT register) instructions load 
and store the contents of the IDTR register, respectively. The LIDT instruction
loads the IDTR register with the base address and limit held in a memory 
operand. This instruction can be executed only when the CPL is 0. It normally is
used by the initalization code of an operating system when creating an IDT. An
operating system also may use it to change from one IDT to another. The SIDT
instruction copies the base and limit value stored in IDTR to memory. This 
instruction can be executed at any privilege level. 

/* basically, SIDT is the getter, LIDT is the setter. */

If a vector references a descriptor beyond the limit of the IDT, a 
general-protection exception (#GP) is generated.
"
	*	*	*

"These two fields perform the same function as the pointer operand in a far 
control-transfer instruction."

Ok, so we next need to lookup-n-understand far control-transfer instructions.
